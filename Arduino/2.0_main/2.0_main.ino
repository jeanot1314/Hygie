/*
 * Arduino code made by Jean Perardel
 * Project Hygie
 * 
 * 04 mai 2020
 */


#include <Wire.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <SoftwareSerial.h>
#include <Adafruit_MLX90614.h>
// Temporary replacement from MAX30100 to MAX30105 because of supply
#include "MAX30100.h"
//#include "MAX30105.h"
#include "heartRate.h"
#include "RTCDS1307.h"
#include <EEPROM.h>

// MPU6050 6-DOF Sensor
#define MPU_ADDR 0x69
#define MEM_START_ADDR 0x6E
#define MEM_R_W 0x6F

// EEPROM cluster definition
#define EEPROM_CLUSTER_SIZE 8

// BLUETOOTH BUFFER SIZE
#define BLUETOOTH_BUFFER_SIZE 32

// define the time (in loop) necessary to consider a short and a long push button
#define Min_Time_Short_Push_Button 2
#define Min_Time_Long_Push_Button 15

// Reset the main counter at :
#define MAX_COUNTER 0xFFFF

// Definition of pseudo real time. Frequency will define the number of time the program
//enter the function on MAX_COUNTER number
#define Buttons_FREQUENCY 128
#define Buttons_FREQUENCY_READ_PER_CYCLE cpt%((MAX_COUNTER/Buttons_FREQUENCY)+1)
#define MAX30100_FREQUENCY 256
#define MAX30100_FREQUENCY_READ_PER_CYCLE cpt%((MAX_COUNTER/MAX30100_FREQUENCY)+1)
#define MLX90614_FREQUENCY 1
#define MLX90614_FREQUENCY_READ_PER_CYCLE cpt%((MAX_COUNTER/MLX90614_FREQUENCY)+1)
#define MPU6050_FREQUENCY 128
#define MPU6050_FREQUENCY_READ_PER_CYCLE cpt%((MAX_COUNTER/MPU6050_FREQUENCY)+1)
#define DS1307_FREQUENCY 1
#define DS1307_FREQUENCY_READ_PER_CYCLE cpt%((MAX_COUNTER/DS1307_FREQUENCY)+1)
#define HC06_FREQUENCY 128
#define HC06_FREQUENCY_READ_PER_CYCLE cpt%((MAX_COUNTER/HC06_FREQUENCY)+1)
#define Serial_FREQUENCY 128
#define Serial_FREQUENCY_READ_PER_CYCLE cpt%((MAX_COUNTER/Serial_FREQUENCY)+1)
#define DimLED_FREQUENCY 64
#define DimLED_FREQUENCY_READ_PER_CYCLE cpt%((MAX_COUNTER/DimLED_FREQUENCY)+1)
#define DebugLED_FREQUENCY 1
#define DebugLED_FREQUENCY_READ_PER_CYCLE cpt%((MAX_COUNTER/DebugLED_FREQUENCY)+1)
#define LEDPushButton_FREQUENCY 16
#define LEDPushButton_FREQUENCY_READ_PER_CYCLE cpt%((MAX_COUNTER/LEDPushButton_FREQUENCY)+1)

//----------------------- Variable for MPU6050 6-DOF Sensor-----------------------------
long lastRead = 0;
byte processed_packet[8];
byte received_packet[50];
byte temp = 0;
byte fifoCountL = 0;
byte fifoCountL2 = 0;
byte packetCount = 0x00;
boolean longPacket = false;
boolean firstPacket = true;
float q[4];

//This 3D array contains the default DMP memory bank binary that gets loaded during initialization.
//In the Invensense UC3-A3 firmware this is uploaded in 128 byte tranmissions, but the Arduino Wire
//library only supports 32 byte transmissions, including the register address to which you're writing,
//so I broke it up into 16 byte transmission payloads which are sent in the dmp_init() function below.
//
//This was reconstructed from observed I2C traffic generated by the UC3-A3 demo code, and not extracted
//directly from that code. That is true of all transmissions in this sketch, and any documentation has
//been added after the fact by referencing the Invensense code.

// this tab takes 6% of memory program storage 
unsigned const char dmpMem[8][16][16] PROGMEM = {
  {
    {0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00},
    {0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01},
    {0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01},
    {0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00},
    {0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00},
    {0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82},
    {0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00},
    {0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0},
    {0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC},
    {0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4},
    {0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10}
  },
  {
    {0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8},
    {0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7},
    {0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C},
    {0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C},
    {0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0}
  },
  {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00},
    {0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
  },
  {
    {0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F},
    {0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2},
    {0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF},
    {0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C},
    {0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1},
    {0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01},
    {0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80},
    {0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C},
    {0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80},
    {0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E},
    {0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9},
    {0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24},
    {0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0},
    {0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86},
    {0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1},
    {0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86}
  },
  {
    {0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA},
    {0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C},
    {0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8},
    {0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3},
    {0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84},
    {0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5},
    {0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3},
    {0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1},
    {0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5},
    {0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D},
    {0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9},
    {0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D},
    {0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9},
    {0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A},
    {0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8},
    {0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87}
  },
  {
    {0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8},
    {0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68},
    {0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D},
    {0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94},
    {0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA},
    {0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56},
    {0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9},
    {0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA},
    {0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A},
    {0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60},
    {0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97},
    {0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04},
    {0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78},
    {0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79},
    {0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68},
    {0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68}
  },
  {
    {0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04},
    {0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66},
    {0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31},
    {0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60},
    {0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76},
    {0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56},
    {0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD},
    {0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91},
    {0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8},
    {0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE},
    {0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9},
    {0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD},
    {0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E},
    {0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8},
    {0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89},
    {0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79}
  },
  {
    {0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8},
    {0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA},
    {0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB},
    {0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3},
    {0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3},
    {0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3},
    {0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3},
    {0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC},
    {0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF}
  }
};

//DMP update transmissions (Bank, Start Address, Update Length, Update Data...)
// 13% of global variables
static byte dmp_updates[29][9] =
{
  {0x03, 0x7B, 0x03, 0x4C, 0xCD, 0x6C} //FCFG_1 inv_set_gyro_calibration
  ,{0x03, 0xAB, 0x03, 0x36, 0x56, 0x76} //FCFG_3 inv_set_gyro_calibration
  ,{0x00, 0x68, 0x04, 0x02, 0xCB, 0x47, 0xA2} //D_0_104 inv_set_gyro_calibration
  ,{0x02, 0x18, 0x04, 0x00, 0x05, 0x8B, 0xC1} //D_0_24 inv_set_gyro_calibration
  ,{0x01, 0x0C, 0x04, 0x00, 0x00, 0x00, 0x00} //D_1_152 inv_set_accel_calibration
  ,{0x03, 0x7F, 0x06, 0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97} //FCFG_2 inv_set_accel_calibration
  ,{0x03, 0x89, 0x03, 0x26, 0x46, 0x66} //FCFG_7 inv_set_accel_calibration
  ,{0x00, 0x6C, 0x02, 0x20, 0x00} //D_0_108 inv_set_accel_calibration
  ,{0x02, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00} //CPASS_MTX_00 inv_set_compass_calibration
  ,{0x02, 0x44, 0x04, 0x00, 0x00, 0x00, 0x00} //CPASS_MTX_01
  ,{0x02, 0x48, 0x04, 0x00, 0x00, 0x00, 0x00} //CPASS_MTX_02
  ,{0x02, 0x4C, 0x04, 0x00, 0x00, 0x00, 0x00} //CPASS_MTX_10
  ,{0x02, 0x50, 0x04, 0x00, 0x00, 0x00, 0x00} //CPASS_MTX_11
  ,{0x02, 0x54, 0x04, 0x00, 0x00, 0x00, 0x00} //CPASS_MTX_12
  ,{0x02, 0x58, 0x04, 0x00, 0x00, 0x00, 0x00} //CPASS_MTX_20
  ,{0x02, 0x5C, 0x04, 0x00, 0x00, 0x00, 0x00} //CPASS_MTX_21
  ,{0x02, 0xBC, 0x04, 0x00, 0x00, 0x00, 0x00} //CPASS_MTX_22
  ,{0x01, 0xEC, 0x04, 0x00, 0x00, 0x40, 0x00} //D_1_236 inv_apply_endian_accel
  ,{0x03, 0x7F, 0x06, 0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97} //FCFG_2 inv_set_mpu_sensors
  ,{0x04, 0x02, 0x03, 0x0D, 0x35, 0x5D} //CFG_MOTION_BIAS inv_turn_on_bias_from_no_motion
  ,{0x04, 0x09, 0x04, 0x87, 0x2D, 0x35, 0x3D} //FCFG_5 inv_set_bias_update
  ,{0x00, 0xA3, 0x01, 0x00} //D_0_163 inv_set_dead_zone
  ,//SET INT_ENABLE at i=22
   {0x07, 0x86, 0x01, 0xFE} //CFG_6 inv_set_fifo_interupt
  ,{0x07, 0x41, 0x05, 0xF1, 0x20, 0x28, 0x30, 0x38} //CFG_8 inv_send_quaternion
  ,{0x07, 0x7E, 0x01, 0x30} //CFG_16 inv_set_footer
  ,{0x07, 0x46, 0x01, 0x9A} //CFG_GYRO_SOURCE inv_send_gyro
  ,{0x07, 0x47, 0x04, 0xF1, 0x28, 0x30, 0x38} //CFG_9 inv_send_gyro -> inv_construct3_fifo
  ,{0x07, 0x6C, 0x04, 0xF1, 0x28, 0x30, 0x38} //CFG_12 inv_send_accel -> inv_construct3_fifo
  ,{0x02, 0x16, 0x02, 0x00, 0x0A} //D_0_22 inv_set_fifo_rate
};

/*
 * PIN Description : 
 *  D0 Serial DEBUG USB RX
 *  D1 Serial DEBUG USB TX 
 *  D2 Serial Bluetooth RX
 *  D3 Serial Bluetooth TX
 *  D4 Button 1
 *  D5 Button 2
 *  D6 Button 3
 *  D7 Button 4
 *  D8 LED RGB Green
 *  D9 LED RGB BLUE
 *  D10 LED RGB RED
 *  D11 --------------->UNUSED
 *  D12 --------------->UNUSED
 *  D13 LED DEBUG
 *  A0 --------------->UNUSED
 *  A1 --------------->UNUSED
 *  A2 --------------->UNUSED
 *  A3 --------------->UNUSED
 *  A4 SDA I2C >> 6-DOF / RTC / Temperature / Heart Rate
 *  A5 SCL I2C >> 6-DOF / RTC / Temperature / Heart Rate
 */

int Button_1_Pin = 7;
int Button_2_Pin = 6;
int Button_3_Pin = 5;
int Button_4_Pin = 4;
int ledRGB_Green_Pin = 8;
int ledRGB_Blue_Pin = 9;       // LED dimmer connected to digital pin 9
int ledRGB_Red_Pin = 10;
int ledDebug_Pin = 13;    // LED Debug connected to digital 13 

byte Button_1_press = 0;
byte Button_2_press = 0;
byte Button_3_press = 0;
byte Button_4_press = 0;
int Button_1_press_cpt = 0;
int Button_2_press_cpt = 0;
int Button_3_press_cpt = 0;
int Button_4_press_cpt = 0;
int double_click_Button_1_cpt = 0;
int double_click_Button_2_cpt = 0;
int double_click_Button_3_cpt = 0;
int double_click_Button_4_cpt = 0;

unsigned int cpt=0; // General system counter
int device_MODE = 0;
bool stop_LEDPushButton=0;
int cpt_LEDPushButton = 0;

bool flag_init_MPU6050=0;
bool flag_init_MLX90614=0;
bool flag_init_MAX30105=0;
bool flag_init_LED_DIMMER=0;

// LED Dimmer management
unsigned int fadeValue=0;
bool fadeDirection=0;

// EEPROM storage format
int EEPROM_current_addr = 0;
int ptr_empty_cluster = 0;
struct EEPROM_Cluster {
  uint8_t year;
  uint8_t month;
  uint8_t day;
  uint8_t hour;
  uint8_t minute;
  uint8_t second;
  uint8_t symptom;
  uint8_t value;
};

//Define a external Serial port on PIN 2 and 3 to keep the main Serial for DEBUG
SoftwareSerial hc06(2,3); // RXPIN TXPIN

// Definition of distant temperature sensor
Adafruit_MLX90614 mlx = Adafruit_MLX90614();

//------------------MAX30105
MAX30100 sensor;
//MAX30105 particleSensor;
const byte RATE_SIZE = 4; //Increase this for more averaging. 4 is good.
byte rates[RATE_SIZE]; //Array of heart rates
byte rateSpot = 0;
long lastBeat = 0; //Time at which the last beat occurred
float beatsPerMinute;
int beatAvg;

//// Variable to manage DS1307 RTC
RTCDS1307 rtc(0x68);

//----------------------------------PROGRAM SETUP---------------------------------------
void setup() {
  Serial.begin(9600);
  Serial.println("-------------------- START PROGRAM--------------------");
  pin_init(); // Initialize input/output PIN
  Wire.begin();
  hc06_init();
  DS1307_init();
  MAX30100_init();
  //MAX30105_init(); // turn sensor LED OFF
  EEPROM_init();
  delay(1); 
  Serial.println("-------------------- START PROGRAM MAIN LOOP --------------------");
}
//----------------------------------PROGRAM LOOP---------------------------------------
void loop() {

  // Button management
  if (Buttons_FREQUENCY_READ_PER_CYCLE == 0){Button_read();}  

  // LED DIMMER : MODE 1
  if (DimLED_FREQUENCY_READ_PER_CYCLE == 0 && device_MODE==1){
    if(!flag_init_LED_DIMMER){flag_init_LED_DIMMER=1;}
    DimLED_write();
  }

  // Heart rate : MODE 2
  if (MAX30100_FREQUENCY_READ_PER_CYCLE == 0 && device_MODE==2){
    if(!flag_init_MAX30105){ MAX30100_read();delay(10);flag_init_MAX30105=1;}
   
  }
  
  // Temperature : MODE 3
  if (MLX90614_FREQUENCY_READ_PER_CYCLE == 0 && device_MODE==3){
    if(!flag_init_MLX90614){
     //mlx.begin();
     Serial.println("START READING TEMPERATURE : ");
     digitalWrite(ledRGB_Red_Pin, LOW);
      flag_init_MLX90614=1;
   }
   //MLX90614_read();
  }
  
  // 6-DOF : MODE 4
  if (MPU6050_FREQUENCY_READ_PER_CYCLE == 0 && device_MODE==4){
    if(!flag_init_MPU6050){MPU6050_init();delay(10);flag_init_MPU6050=1;}
    MPU6050_read();
  }
 
  // Bluetooth read/write
  if (HC06_FREQUENCY_READ_PER_CYCLE == 0){HC06_readWrite();}
  // Serial read/write
  if (Serial_FREQUENCY_READ_PER_CYCLE == 0){Serial_readWrite();}
  // Blink DEBUG LED
  if (DebugLED_FREQUENCY_READ_PER_CYCLE == 0){DebugLED_write();}
  // Read Clock, print info
  if (DS1307_FREQUENCY_READ_PER_CYCLE == 0 && device_MODE==5){DebugINFO_write();}
  // Blink green LED when button press
  if (LEDPushButton_FREQUENCY_READ_PER_CYCLE == 0){
    if (cpt_LEDPushButton){
      cpt_LEDPushButton--;
      stop_LEDPushButton=1;
    }
    else if (stop_LEDPushButton){
      digitalWrite(ledRGB_Green_Pin, HIGH);
      stop_LEDPushButton=0;
    }  
  }
  
  // Set flags back to 0
  if (DebugLED_FREQUENCY_READ_PER_CYCLE == 0){
    if(device_MODE != 1 && flag_init_LED_DIMMER == 1){
      digitalWrite(ledRGB_Blue_Pin, HIGH);
      flag_init_LED_DIMMER=0;
    }
    if(device_MODE != 2 && flag_init_MAX30105 == 1){
      flag_init_MAX30105=0;
      MAX30100_init();
    }
    if(device_MODE != 3 && flag_init_MLX90614 == 1){
      digitalWrite(ledRGB_Red_Pin, HIGH);
      flag_init_MLX90614=0;
    }
    if(device_MODE != 4 && flag_init_MPU6050 == 1){
      flag_init_MPU6050=0;
    }
  }
  
  if(cpt == MAX_COUNTER){cpt=0;}
  else{cpt++;}
  
}

// --------------------General functions--------------------
void pin_init() {
  pinMode(ledRGB_Blue_Pin, OUTPUT);
  digitalWrite(ledRGB_Blue_Pin, HIGH);
  pinMode(ledRGB_Green_Pin, OUTPUT);
  digitalWrite(ledRGB_Green_Pin, HIGH);
  pinMode(ledRGB_Red_Pin, OUTPUT);
  digitalWrite(ledRGB_Red_Pin, HIGH);

  pinMode(ledDebug_Pin, OUTPUT);
  digitalWrite(ledDebug_Pin, LOW);
  
  pinMode(Button_1_Pin, INPUT);
  pinMode(Button_2_Pin, INPUT);
  pinMode(Button_3_Pin, INPUT);
  pinMode(Button_4_Pin, INPUT);
}

void DebugINFO_write() {
  Serial.print("SYSTEM INFO : ");
  uint8_t year, month, weekday, day, hour, minute, second;
  bool period = 0;  
  rtc.getDate(year, month, day, weekday);
  rtc.getTime(hour, minute, second, period);
  Serial.print(day, DEC);Serial.print("/");
  Serial.print(month);Serial.print("/");
  Serial.print(year + 2000, DEC);Serial.print("  ");
  Serial.print(hour, DEC);Serial.print(":");
  Serial.print(minute, DEC);Serial.print(":");
  Serial.print(second, DEC);Serial.print(" --- ");
  
  Serial.print("MODE=");Serial.print(device_MODE);Serial.print(" --- ");
  EEPROM_checkData();
  //Serial.println();
}

void DebugLED_write() {
  digitalWrite(ledDebug_Pin, !digitalRead(ledDebug_Pin));
}

// --------------------Buttons and mode management--------------------
void Button_read(){
  
  // --------------Button 1--------------
  int Button_Statut = 0;

  if (Button_1_press_cpt >= Min_Time_Short_Push_Button && Button_1_press_cpt < Min_Time_Long_Push_Button && (digitalRead(Button_1_Pin))==1){Button_Statut=1;}
  else if (Button_1_press_cpt >= Min_Time_Long_Push_Button && (digitalRead(Button_1_Pin))==1){Button_Statut=2;}
  
  if(Button_Statut == 1){
    if(double_click_Button_1_cpt > 0){
      Serial.print("Double Short Press Button 1  ");
      EEPROM_addValue(5, 0);
      Serial.println();
    }
    else{
      Serial.println("Short Press Button 1  ");
      EEPROM_addValue(1, 0);
      Serial.println();
    }
    Button_1_press++;
    device_MODE=0;
    Button_1_press_cpt=0;
    double_click_Button_1_cpt=20;
    //mode_init();
    cpt_LEDPushButton=0x01;
    digitalWrite(ledRGB_Green_Pin, LOW);
  }
  else if(Button_Statut == 2){
    Serial.println("Long Press Button 1");
    device_MODE=1;
    Button_1_press_cpt=0;
  }
  // Replace this call for Button press time debug
  //if((digitalRead(Button_1_Pin))==0){Button_1_press_cpt++;Serial.println(Button_1_press_cpt);}
  if((digitalRead(Button_1_Pin))==0){Button_1_press_cpt++;}
  else{
    Button_1_press_cpt=0;
    if(double_click_Button_1_cpt > 0){
      double_click_Button_1_cpt--;
    }  
  }

  // --------------Button 2--------------
  Button_Statut=0;
  if (Button_2_press_cpt >= Min_Time_Short_Push_Button && Button_2_press_cpt < Min_Time_Long_Push_Button && (digitalRead(Button_2_Pin))==1){Button_Statut=1;}
  else if (Button_2_press_cpt >= Min_Time_Long_Push_Button && (digitalRead(Button_2_Pin))==1){Button_Statut=2;}
  
  if(Button_Statut == 1){
    if(double_click_Button_2_cpt > 0){
      Serial.print("Double Short Press Button 2  ");
      EEPROM_addValue(6, 0);
      Serial.println();
    }
    else{
      Serial.print("Short Press Button 2  ");
      EEPROM_addValue(2, 0);
      Serial.println();
    }
    Button_2_press++;
    device_MODE=0;
    Button_2_press_cpt=0;
    double_click_Button_2_cpt=20;
    cpt_LEDPushButton=0x01;
    digitalWrite(ledRGB_Green_Pin, LOW);
  }
  else if(Button_Statut == 2){
    Serial.println("Long Press Button 2");
    device_MODE=2;
    Button_2_press_cpt=0;
  }
  if((digitalRead(Button_2_Pin))==0){Button_2_press_cpt++;}
  else{
    Button_2_press_cpt=0;
    if(double_click_Button_2_cpt > 0){
      double_click_Button_2_cpt--;
    }  
  }

  // --------------Button 3--------------
  Button_Statut=0;
  if (Button_3_press_cpt >= Min_Time_Short_Push_Button && Button_3_press_cpt < Min_Time_Long_Push_Button && (digitalRead(Button_3_Pin))==1){Button_Statut=1;}
  else if (Button_3_press_cpt >= Min_Time_Long_Push_Button && (digitalRead(Button_3_Pin))==1){Button_Statut=2;}
  
  if(Button_Statut == 1){
    if(double_click_Button_3_cpt > 0){
      Serial.print("Double Short Press Button 3  ");
      EEPROM_addValue(7, 0);
      Serial.println();
      }
    else{
      Serial.print("Short Press Button 3  ");
      EEPROM_addValue(3, 0);
      Serial.println();
    }
    Button_3_press++;
    device_MODE=0;
    Button_3_press_cpt=0;
    double_click_Button_3_cpt=20;
    cpt_LEDPushButton=0x01;
    digitalWrite(ledRGB_Green_Pin, LOW);
  }
  else if(Button_Statut == 2){
    Serial.println("Long Press Button 3");
    device_MODE=3;
    Button_3_press_cpt=0;
  }
  if((digitalRead(Button_3_Pin))==0){Button_3_press_cpt++;}
  else{
    Button_3_press_cpt=0;
    if(double_click_Button_3_cpt > 0){
      double_click_Button_3_cpt--;
    }      
  }

  // --------------Button 4--------------
  Button_Statut=0;
  if (Button_4_press_cpt >= Min_Time_Short_Push_Button && Button_4_press_cpt < Min_Time_Long_Push_Button && (digitalRead(Button_4_Pin))==1){Button_Statut=1;}
  else if (Button_4_press_cpt >= Min_Time_Long_Push_Button && (digitalRead(Button_4_Pin))==1){Button_Statut=2;}
  
  if(Button_Statut == 1){
    if(double_click_Button_4_cpt > 0){
      Serial.print("Double Short Press Button 4  ");
      EEPROM_addValue(8, 0);
      Serial.println();
      }
    else{
      Serial.print("Short Press Button 4  ");
      EEPROM_addValue(4, 0);
      Serial.println(); 
    }
    Button_4_press++;
    device_MODE=0;
    Button_4_press_cpt=0;
    double_click_Button_4_cpt=20;
    cpt_LEDPushButton=0x01;
    digitalWrite(ledRGB_Green_Pin, LOW);
  }
  else if(Button_Statut == 2){
    Serial.println("Long Press Button 4");
    device_MODE=4;
    Button_4_press_cpt=0;    
  }
  if((digitalRead(Button_4_Pin))==0){Button_4_press_cpt++;}
  else{
    Button_4_press_cpt=0;
    if(double_click_Button_4_cpt > 0){
      double_click_Button_4_cpt--;
    }  
  }
}

// --------------------Dimmer LED--------------------
void DimLED_write() {
    analogWrite(ledRGB_Blue_Pin, fadeValue);
    if(fadeDirection==0){fadeValue=fadeValue+8;}
    else if(fadeDirection==1){fadeValue=fadeValue-8;}
    if (fadeValue > 255 && fadeValue <= 0x7FFF){
      fadeDirection=1;
      fadeValue=255;
    }
    else if (fadeValue > 0x7FFF){
      fadeDirection=0;
      fadeValue=0;
    }
}

// ---------------Bluetooth management--------------------------
void HC06_readWrite() {
  char RxBLE_data[BLUETOOTH_BUFFER_SIZE];
  int RxBLE_data_cpt=0;
  
  for(int i=0; i<BLUETOOTH_BUFFER_SIZE;i++){RxBLE_data[i]=0;}

  // While data are available on serial port, keep going. The delay is important to don't go faster than Bluetooth communication 
  while (hc06.available() && RxBLE_data_cpt<BLUETOOTH_BUFFER_SIZE){
    RxBLE_data[RxBLE_data_cpt] = hc06.read();
    //Serial.write(RxBLE_data[RxBLE_data_cpt]);
    RxBLE_data_cpt++;
    delay(1);
  }
  
  if(RxBLE_data[0] != 0){
    Serial.print("Receive : ");      
    if(memcmp(RxBLE_data, "BLE_Ready", 9) == 0){
      Serial.write(RxBLE_data);
      Serial.print(" : ");

      if(EEPROM_checkData()){
        EEPROM_Cluster EEPROM_cluster; // Create an EEPROM frame
        EEPROM_readValue(ptr_empty_cluster, &EEPROM_cluster);
        hc06.write('*'); // Start character protocol
        hc06.write(EEPROM_cluster.symptom); // 8 byte payload
        hc06.write(EEPROM_cluster.value);
        hc06.write(EEPROM_cluster.hour);
        hc06.write(EEPROM_cluster.minute);
        hc06.write(EEPROM_cluster.second);
        hc06.write(EEPROM_cluster.day);
        hc06.write(EEPROM_cluster.month);
        hc06.write(EEPROM_cluster.year);
        hc06.write('~');// End character protocol

        // For DEBUG on Serial
        Serial.print("Send Frame : ");
        Serial.print('*');Serial.print(" ");
        Serial.print(EEPROM_cluster.symptom);Serial.print(" ");
        Serial.print(EEPROM_cluster.value);Serial.print(" ");
        Serial.print(EEPROM_cluster.hour);Serial.print("-");
        Serial.print(EEPROM_cluster.minute);Serial.print("-");
        Serial.print(EEPROM_cluster.second);Serial.print(" - ");
        Serial.print(EEPROM_cluster.day);Serial.print("/");
        Serial.print(EEPROM_cluster.month);Serial.print("/");          
        Serial.print(EEPROM_cluster.year);Serial.print(" - ");
        Serial.print('~');
        
        ptr_empty_cluster++;     
      }
      else{
        ptr_empty_cluster=0;
        hc06.write('!');
        Serial.println("END OF DATA BLUETOOTH SEND");
        EEPROM_clear();
      } 
    }
    else if((RxBLE_data[0] == '0' || RxBLE_data[0] == '1') && (RxBLE_data[1] >= '0' &&  RxBLE_data[1] <= '9') && RxBLE_data[2] >= '/' && (RxBLE_data[3] >= '0' &&  RxBLE_data[3] <= '3') && (RxBLE_data[4] >= '0' &&  RxBLE_data[4] <= '9') ){
        Serial.print("Setting time ");
        Serial.write(RxBLE_data);
        String tmp = "";
        tmp += RxBLE_data[0];
        tmp += RxBLE_data[1];
        int month_tmp = tmp.toInt();
        tmp = "";
        tmp += RxBLE_data[3];
        tmp += RxBLE_data[4];
        int day_tmp = (tmp.toInt());
        tmp = "";
        tmp += RxBLE_data[6];
        tmp += RxBLE_data[7];
        tmp += RxBLE_data[8];
        tmp += RxBLE_data[9];
        int year_tmp = tmp.toInt();
        year_tmp-=2000;
        tmp = "";
        tmp += RxBLE_data[11];
        tmp += RxBLE_data[12];
        int hour_tmp = tmp.toInt();
        tmp = "";
        tmp += RxBLE_data[14];
        tmp += RxBLE_data[15];
        int minute_tmp = tmp.toInt();
        tmp = "";
        tmp += RxBLE_data[17];
        tmp += RxBLE_data[18];
        int seconde_tmp = tmp.toInt();
        rtc.setDate(year_tmp, month_tmp, day_tmp);
        rtc.setTime(hour_tmp, minute_tmp, seconde_tmp);
    }
    else if(memcmp(RxBLE_data, "Set_Mode_0", 10) == 0){
      device_MODE=0;
      digitalWrite(ledRGB_Red_Pin, HIGH);
      digitalWrite(ledRGB_Green_Pin, HIGH);
      digitalWrite(ledRGB_Blue_Pin, HIGH);
      Serial.write(RxBLE_data);
    }
    else if(memcmp(RxBLE_data, "Set_Mode_1", 10) == 0){
      device_MODE=1;
      Serial.write(RxBLE_data);
    }
    else if(memcmp(RxBLE_data, "Set_Mode_2", 10) == 0){
      device_MODE=2;
      Serial.write(RxBLE_data);
    }
    else if(memcmp(RxBLE_data, "Set_Mode_3", 10) == 0){
      device_MODE=3;
      Serial.write(RxBLE_data);
    }
    else if(memcmp(RxBLE_data, "Set_Mode_4", 10) == 0){
      device_MODE=4;
      Serial.write(RxBLE_data);
    }
    else if(memcmp(RxBLE_data, "Set_LED_R", 9) == 0){
      digitalWrite(ledRGB_Red_Pin, LOW);
      Serial.write(RxBLE_data);
    }
    else if(memcmp(RxBLE_data, "Set_LED_G", 9) == 0){
      digitalWrite(ledRGB_Green_Pin, LOW);
      Serial.write(RxBLE_data);
    }
    else if(memcmp(RxBLE_data, "Set_LED_B", 9) == 0){
      digitalWrite(ledRGB_Blue_Pin, LOW);
      Serial.write(RxBLE_data);
    }
    else if(memcmp(RxBLE_data, "Set_LED_O", 9) == 0){
      digitalWrite(ledRGB_Red_Pin, HIGH);
      digitalWrite(ledRGB_Green_Pin, HIGH);
      digitalWrite(ledRGB_Blue_Pin, HIGH);
      Serial.write(RxBLE_data);
    }
    else{
      //Serial.write(RxBLE_data[0]);
      //Serial.print("--");
      //Serial.write(RxBLE_data[1]);
      //Serial.println();
      Serial.write(RxBLE_data);
    }
  Serial.println();   
}
}

// Serial management
void Serial_readWrite(){
  char RxSerial_data[16];
  int RxSerial_data_cpt=0;
  for(int i=0; i<16;i++){RxSerial_data[i]=0;}
  
  while (Serial.available()){
    RxSerial_data[RxSerial_data_cpt] = Serial.read();
    RxSerial_data_cpt++;
    delay(1);
  }

  if(RxSerial_data[0] != 0){
    Serial.print("Send : ");
    if (RxSerial_data[0] == 'V'){
      hc06.write(RxSerial_data);
      Serial.write(RxSerial_data);

      Serial.print(" START TO WRITE MEMORY ");
    }
    else{
      hc06.write(RxSerial_data);
      Serial.write(RxSerial_data);
    }
    Serial.println();    
  }
}

// --------------------------------------------EEPROM management--------------------------------------------

// read memory, check the last address, add the value to the next one (if buttonNumber>4, set value to the last one). If memory is full, circular buffer. 
void EEPROM_addValue(int buttonNumber, int val){

  EEPROM_Cluster EEPROM_cluster;
  uint8_t dayweek=0;
  bool period_set=0;
  rtc.getDate(EEPROM_cluster.year, EEPROM_cluster.month, EEPROM_cluster.day, dayweek);
  rtc.getTime(EEPROM_cluster.hour, EEPROM_cluster.minute, EEPROM_cluster.second, period_set);
 
  EEPROM_cluster.symptom=buttonNumber;
  EEPROM_cluster.value=val;

  if(EEPROM_current_addr<EEPROM.length()){
    if(4 < buttonNumber && buttonNumber <= 8 && EEPROM_current_addr >= sizeof(EEPROM_Cluster)){
      EEPROM_current_addr-=sizeof(EEPROM_Cluster);
    }
    EEPROM.put(EEPROM_current_addr, EEPROM_cluster);
    EEPROM_current_addr+=sizeof(EEPROM_Cluster);
  }
  else{
    Serial.println("-----Memory FULL----- Please transfert data on your phone");
  }
  //Serial.print("STORAGE PTR : ");Serial.print(EEPROM_current_addr);
  Serial.print("  DATA : ");Serial.print(EEPROM_cluster.year);Serial.print("/");Serial.print(EEPROM_cluster.month);Serial.print("/");Serial.print(EEPROM_cluster.day);Serial.print(" ");
  Serial.print(EEPROM_cluster.hour);Serial.print("-");Serial.print(EEPROM_cluster.minute);Serial.print("-");Serial.print(EEPROM_cluster.second);Serial.print(" Symptom ");
  Serial.print(EEPROM_cluster.symptom);Serial.print(" VAL ");Serial.print(EEPROM_cluster.value);Serial.println();
}

bool EEPROM_readValue(int eeprom_cluster_nb, EEPROM_Cluster* EEPROM_cluster){
  int index=0;
  bool data_present=0;
  int number_cluster=0;
  eeprom_cluster_nb=eeprom_cluster_nb*8;
  if(1 <= EEPROM[eeprom_cluster_nb] && EEPROM[eeprom_cluster_nb] <= 99   && 0 <= EEPROM[eeprom_cluster_nb+1] && EEPROM[eeprom_cluster_nb+1] <= 12 && 0 <= EEPROM[eeprom_cluster_nb+2] && EEPROM[eeprom_cluster_nb+2] <= 31){
    if(0 <= EEPROM[eeprom_cluster_nb+3] && EEPROM[eeprom_cluster_nb+3] <= 24 && 0 <= EEPROM[eeprom_cluster_nb+4] && EEPROM[eeprom_cluster_nb+4] <= 60 && 0 <= EEPROM[eeprom_cluster_nb+5] && EEPROM[eeprom_cluster_nb+5] <= 60){
      if(0 <= EEPROM[eeprom_cluster_nb+6] && EEPROM[eeprom_cluster_nb+6] <= 10){
        EEPROM_cluster->year=EEPROM[eeprom_cluster_nb];
        EEPROM_cluster->month=EEPROM[eeprom_cluster_nb+1];
        EEPROM_cluster->day=EEPROM[eeprom_cluster_nb+2];
        EEPROM_cluster->hour=EEPROM[eeprom_cluster_nb+3];
        EEPROM_cluster->minute=EEPROM[eeprom_cluster_nb+4];
        EEPROM_cluster->second=EEPROM[eeprom_cluster_nb+5];
        EEPROM_cluster->symptom=EEPROM[eeprom_cluster_nb+6];
        EEPROM_cluster->value=EEPROM[eeprom_cluster_nb+7];
        //Serial.print("  DATA READ : ");Serial.print(EEPROM_cluster->year);Serial.print("/");Serial.print(EEPROM_cluster->month);Serial.print("/");Serial.print(EEPROM_cluster->day);Serial.print(" ");
        //Serial.print(EEPROM_cluster->hour);Serial.print("-");Serial.print(EEPROM_cluster->minute);Serial.print("-");Serial.print(EEPROM_cluster->second);Serial.print(" Symptom ");
        //Serial.print(EEPROM_cluster->symptom);Serial.print(" VAL ");Serial.print(EEPROM_cluster->value);Serial.println();
        data_present=1;
        number_cluster++;
      }
    }
  }
  return data_present;  
}

void EEPROM_init(){
  EEPROM_current_addr = (EEPROM_checkData() * sizeof(EEPROM_Cluster));
}

// send back the number of data in memory
int EEPROM_checkData(){
  int index=0;
  int number_cluster=0;
  bool flag_EEPROM_END=0;
  while (index < EEPROM.length() && flag_EEPROM_END == 0) {
    if(1 <= EEPROM[index] && EEPROM[index] <= 99 && 0 <= EEPROM[index+1] && EEPROM[index+1] <= 12 && 0 <= EEPROM[index+2] && EEPROM[index+2] <= 31){
      if(0 <= EEPROM[index+3] && EEPROM[index+3] <= 24 && 0 <= EEPROM[index+4] && EEPROM[index+4] <= 60 && 0 <= EEPROM[index+5] && EEPROM[index+5] <= 60){
        if(0 <= EEPROM[index+6] && EEPROM[index+6] <= 10){

          //Serial.print("  DATA READ : ");Serial.print(EEPROM[index]);Serial.print("/");Serial.print(EEPROM[index+1]);Serial.print("/");Serial.print(EEPROM[index+2]);Serial.print(" ");
          //Serial.print(EEPROM[index+3]);Serial.print("-");Serial.print(EEPROM[index+4]);Serial.print("-");Serial.print(EEPROM[index+5]);Serial.print(" Symptom ");
          //Serial.print(EEPROM[index+6]);Serial.print(" VAL ");Serial.print(EEPROM[index+7]);Serial.println();
          index+=sizeof(EEPROM_Cluster);
          number_cluster++;
        }else{
          flag_EEPROM_END=3;
        }
      }else{
        flag_EEPROM_END=2;
      }
    }else{
      flag_EEPROM_END=1;
    }
  }
  Serial.print("Block in memory : ");
  Serial.print(number_cluster-ptr_empty_cluster);
  if(number_cluster > 0){
    Serial.print(" - First : ");
    index=0;
    Serial.print(EEPROM[index]);Serial.print("/");Serial.print(EEPROM[index+1]);Serial.print("/");Serial.print(EEPROM[index+2]);Serial.print(" ");
    Serial.print(EEPROM[index+3]);Serial.print("-");Serial.print(EEPROM[index+4]);Serial.print("-");Serial.print(EEPROM[index+5]);Serial.print(" Symptom ");
    Serial.print(EEPROM[index+6]);Serial.print(" VAL ");Serial.print(EEPROM[index+7]);

    if(number_cluster > 1){
      Serial.print(" - Last : ");
      index=(number_cluster-1)*8;
      Serial.print(EEPROM[index]);Serial.print("/");Serial.print(EEPROM[index+1]);Serial.print("/");Serial.print(EEPROM[index+2]);Serial.print(" ");
      Serial.print(EEPROM[index+3]);Serial.print("-");Serial.print(EEPROM[index+4]);Serial.print("-");Serial.print(EEPROM[index+5]);Serial.print(" Symptom ");
      Serial.print(EEPROM[index+6]);Serial.print(" VAL ");Serial.print(EEPROM[index+7]);
    }
  }
  Serial.println();
  return number_cluster;
}

// set all the memory to 0
void EEPROM_clear(){
  for (int i = 0 ; i < EEPROM.length() ; i++) {
    EEPROM.write(i, 0);
  }
  EEPROM_current_addr=0;
}

// send back the number of data in memory
int EEPROM_print(){
  int index=0;
  int number_cluster=0;
  bool flag_EEPROM_END=0;
  EEPROM_checkData();
  for(int i=0;i<16;i++) {
          Serial.print("  DATA READ : ");Serial.print(EEPROM[index]);Serial.print("/");Serial.print(EEPROM[index+1]);Serial.print("/");Serial.print(EEPROM[index+2]);Serial.print(" ");
          Serial.print(EEPROM[index+3]);Serial.print("-");Serial.print(EEPROM[index+4]);Serial.print("-");Serial.print(EEPROM[index+5]);Serial.print(" Symptom ");
          Serial.print(EEPROM[index+6]);Serial.print(" VAL ");Serial.print(EEPROM[index+7]);Serial.println();
          index+=sizeof(EEPROM_Cluster);
  }
  return number_cluster;
}

// --------------------DS1307 RTC Clock functions--------------------
void DS1307_init(){
  rtc.begin();
  //rtc.setDate(19, 2, 28);
  //rtc.setTime(23, 59, 50);
  rtc.setMode(0);
}

void DS1307_read(){
  uint8_t year, month, weekday, day, hour, minute, second;
  bool period = 0;
  rtc.getDate(year, month, day, weekday);
  rtc.getTime(hour, minute, second, period);
  //if (!(second % 3)) rtc.setMode(1 - rtc.getMode());
  rtc.getTime(hour, minute, second, period);

  Serial.print(weekday);
  Serial.print("  ");
  Serial.print(day, DEC);
  Serial.print("/");
  Serial.print(month);
  Serial.print("/");
  Serial.print(year + 2000, DEC);
  Serial.print("  ");
  Serial.print(hour, DEC);
  Serial.print(":");
  Serial.print(minute, DEC);
  Serial.print(":");
  Serial.print(second, DEC);
  //Serial.print(rtc.getMode() ? (period ? " PM" : " AM") : "");
  Serial.println();
  //delay(1000); 
}

// --------------------MLX90614 Temperature Sensor--------------------
void MLX90614_read(){
/*  Serial.print("Ambient = "); 
  Serial.print(mlx.readAmbientTempC()); 
  Serial.print("*C\tObject = "); 
  Serial.print(mlx.readObjectTempC()); Serial.println("*C");
  Serial.print("Ambient = "); 
  Serial.print(mlx.readAmbientTempF()); 
  Serial.print("*F\tObject = "); 
  Serial.print(mlx.readObjectTempF()); Serial.println("*F");
  Serial.println();*/
  //delay(500);
}

// --------------------MAX30100 Pulse Sensor--------------------

void MAX30100_init() {
  sensor.begin(pw1600, i50, sr100 );
}

void MAX30100_read(){
  sensor.readSensor();
  Serial.println(meanDiff(sensor.IR));    
}

long meanDiff(int M) {
  #define LM_SIZE 15
  static int LM[LM_SIZE];      // LastMeasurements
  static byte index = 0;
  static long sum = 0;
  static byte count = 0;
  long avg = 0;

  // keep sum updated to improve speed.
  sum -= LM[index];
  LM[index] = M;
  sum += LM[index];
  index++;
  index = index % LM_SIZE;
  if (count < LM_SIZE) count++;

  avg = sum / count;
  return avg - M;
}

// --------------------MAX30105 Pulse Sensor--------------------
/*void MAX30105_init() {
  // Initialize sensor
  if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) //Use default I2C port, 400kHz speed
  {
    Serial.println("MAX30105 was not found. Please check wiring/power. ");
  }
  else
  {
    //Serial.println("Place your index finger on the sensor with steady pressure.");
  
    //Setup to sense a nice looking saw tooth on the plotter
    byte ledBrightness = 0x00; //Options: 0=Off to 255=50mA
    byte sampleAverage = 8; //Options: 1, 2, 4, 8, 16, 32
    byte ledMode = 3; //Options: 1 = Red only, 2 = Red + IR, 3 = Red + IR + Green
    int sampleRate = 100; //Options: 50, 100, 200, 400, 800, 1000, 1600, 3200
    int pulseWidth = 411; //Options: 69, 118, 215, 411
    int adcRange = 4096; //Options: 2048, 4096, 8192, 16384
    
    particleSensor.setup(ledBrightness, sampleAverage, ledMode, sampleRate, pulseWidth, adcRange); //Configure sensor with these settings
    
    //particleSensor.setPulseAmplitudeRed(0x0A); //Turn Red LED to low to indicate sensor is running
    //particleSensor.setPulseAmplitudeGreen(0); //Turn off Green LED    
  }
}

void MAX30105_start() {
  // Setup sensor with LED OFF
    //Setup to sense a nice looking saw tooth on the plotter
    byte ledBrightness = 0x1F; //Options: 0=Off to 255=50mA
    byte sampleAverage = 8; //Options: 1, 2, 4, 8, 16, 32
    byte ledMode = 3; //Options: 1 = Red only, 2 = Red + IR, 3 = Red + IR + Green
    int sampleRate = 100; //Options: 50, 100, 200, 400, 800, 1000, 1600, 3200
    int pulseWidth = 411; //Options: 69, 118, 215, 411
    int adcRange = 4096; //Options: 2048, 4096, 8192, 16384
    
    particleSensor.setup(ledBrightness, sampleAverage, ledMode, sampleRate, pulseWidth, adcRange); //Configure sensor with these settings
}

void MAX30105_read(){
  Serial.println(particleSensor.getIR()); //Send raw data to plotter
  /*
  long irValue = particleSensor.getIR();

  if (checkForBeat(irValue) == true)
  {
    //We sensed a beat!
    long delta = millis() - lastBeat;
    lastBeat = millis();

    beatsPerMinute = 60 / (delta / 1000.0);

    if (beatsPerMinute < 255 && beatsPerMinute > 20)
    {
      rates[rateSpot++] = (byte)beatsPerMinute; //Store this reading in the array
      rateSpot %= RATE_SIZE; //Wrap variable

      //Take average of readings
      beatAvg = 0;
      for (byte x = 0 ; x < RATE_SIZE ; x++)
        beatAvg += rates[x];
      beatAvg /= RATE_SIZE;
    }
  }

  Serial.print("IR=");
  Serial.print(irValue);
  Serial.print(", BPM=");
  Serial.print(beatsPerMinute);
  Serial.print(", Avg BPM=");
  Serial.print(beatAvg);

  if (irValue < 50000)
    Serial.print(" No finger?");

  Serial.println();   
}
*/
// --------------------HC-06 Bluetooth functions--------------------
void hc06_init() {
  hc06.begin(9600);
  //hc06.write('A');
  //hc06.write('T');
  //hc06.write('\n');
}

// --------------------MPU6050 6DOF functions (all the functions left...)--------------------
void MPU6050_init() {
  check_MPU();
  regWrite(0x6B, 0xC0);
  regWrite(0x6C, 0x00);
  delay(10);

  // regWrite(0x6B, 0x70);
  regWrite(0x6B, 0x00);
  regWrite(0x6D, 0x70);
  regWrite(0x6E, 0x06);
  temp = regRead(0x6F);
  //Serial.print("Bank 1, Reg 6 = ");
  //Serial.println(temp, HEX);

  // temp = regRead(0x6B);
  // Serial.println(temp, HEX);

  regWrite(0x6D, 0x00);

  temp = regRead(0x00);
  //Serial.println(temp, HEX);
  temp = regRead(0x01);
  //Serial.println(temp, HEX);
  temp = regRead(0x02);
  //Serial.println(temp, HEX);
  temp = regRead(0x6A);
  //Serial.println(temp, HEX);

  regWrite(0x37, 0x32);

  temp = regRead(0x6B);
  //Serial.println(temp, HEX);
  delay(5);
  // regWrite(0x25, 0x68); //Set Slave 0 to self
  //
  // regWrite(0x6A, 0x02);

  mem_init();
  delay(20);  
}

void MPU6050_read() {
  if (millis() >= lastRead + 10) {
    lastRead = millis();
    if (fifoReady()) {
      getPacket();
      temp = regRead(0x3A);
      if (firstPacket) {
        delay(1);
        bank_sel(0x00);
        regWrite(0x6E, 0x60);
        Wire.beginTransmission(MPU_ADDR);
        Wire.write(0x6F);
        Wire.write(0x04); Wire.write(0x00); Wire.write(0x00); Wire.write(0x00);
        // Wire.write(0x00); Wire.write(0x80); Wire.write(0x00); Wire.write(0x00);
        Wire.endTransmission();
        bank_sel(1);
        regWrite(0x6E, 0x62);
        Wire.beginTransmission(MPU_ADDR);
        Wire.write(0x6F);
        Wire.endTransmission();
        Wire.beginTransmission(MPU_ADDR);
        Wire.requestFrom(MPU_ADDR, 2);
        temp = Wire.read();
        temp = Wire.read();
        firstPacket = false;

        fifoReady();
      }
      // resetFifo();

      if (fifoCountL == 42) {
        processQuat();
        sendQuat();
      }
    }
  }  
}

void dmp_init() {

  for (int i = 0; i < 7; i++) {
    bank_sel(i);
    for (byte j = 0; j < 16; j++) {

      byte start_addy = j * 0x10;
      Wire.beginTransmission(MPU_ADDR);
      Wire.write(MEM_START_ADDR);
      Wire.write(start_addy);
      Wire.endTransmission();

      Wire.beginTransmission(MPU_ADDR);
      Wire.write(MEM_R_W);
      for (int k = 0; k < 16; k++) {
        unsigned char byteToSend = pgm_read_byte(&(dmpMem[i][j][k]));
        Wire.write((byte) byteToSend);
      }
      Wire.endTransmission();
    }
  }

  bank_sel(7);

  for (byte j = 0; j < 8; j++) {

    byte start_addy = j * 0x10;

    Wire.beginTransmission(MPU_ADDR);
    Wire.write(MEM_START_ADDR);
    Wire.write(start_addy);
    Wire.endTransmission();

    Wire.beginTransmission(MPU_ADDR);
    Wire.write(MEM_R_W);
    for (int k = 0; k < 16; k++) {
      unsigned char byteToSend = pgm_read_byte(&(dmpMem[7][j][k]));
      Wire.write((byte) byteToSend);
    }
    Wire.endTransmission();
  }

  Wire.beginTransmission(MPU_ADDR);
  Wire.write(MEM_START_ADDR);
  Wire.write(0x80);
  Wire.endTransmission();

  Wire.beginTransmission(MPU_ADDR);
  Wire.write(MEM_R_W);
  for (int k = 0; k < 9; k++) {
    unsigned char byteToSend = pgm_read_byte(&(dmpMem[7][8][k]));
    Wire.write((byte) byteToSend);
  }
  Wire.endTransmission();

  Wire.beginTransmission(MPU_ADDR);
  Wire.write(MEM_R_W);
  Wire.endTransmission();
  Wire.beginTransmission(MPU_ADDR);
  Wire.requestFrom(MPU_ADDR, 9);
  // Wire.endTransmission();
  byte incoming[9];
  for (int i = 0; i < 9; i++) {
    incoming[i] = Wire.read();
  }
}

void mem_init() {

  dmp_init();

  for (byte i = 0; i < 22; i++) {
    bank_sel(dmp_updates[i][0]);
    Wire.beginTransmission(MPU_ADDR);
    Wire.write(MEM_START_ADDR);
    Wire.write(dmp_updates[i][1]);
    Wire.endTransmission();

    Wire.beginTransmission(MPU_ADDR);
    Wire.write(MEM_R_W);
    for (byte j = 0; j < dmp_updates[i][2]; j++) {
      Wire.write(dmp_updates[i][j + 3]);
    }
    Wire.endTransmission();
  }

  regWrite(0x38, 0x32);

  for (byte i = 22; i < 29; i++) {
    bank_sel(dmp_updates[i][0]);
    Wire.beginTransmission(MPU_ADDR);
    Wire.write(MEM_START_ADDR);
    Wire.write(dmp_updates[i][1]);
    Wire.endTransmission();

    Wire.beginTransmission(MPU_ADDR);
    Wire.write(MEM_R_W);
    for (byte j = 0; j < dmp_updates[i][2]; j++) {
      Wire.write(dmp_updates[i][j + 3]);
    }
    Wire.endTransmission();
  }

  temp = regRead(0x6B);
  //Serial.println(temp, HEX);
  temp = regRead(0x6C);
  //Serial.println(temp, HEX);

  regWrite(0x38, 0x02);
  regWrite(0x6B, 0x03);
  regWrite(0x19, 0x04);
  regWrite(0x1B, 0x18);
  regWrite(0x1A, 0x0B);
  regWrite(0x70, 0x03);
  regWrite(0x71, 0x00);
  regWrite(0x00, 0x00);
  regWrite(0x01, 0x00);
  regWrite(0x02, 0x00);

  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x13);
  for (byte i = 0; i < 6; i++) {
    Wire.write(0x00);
  }
  Wire.endTransmission();

  // regWrite(0x24, 0x00);

  bank_sel(0x01);
  regWrite(0x6E, 0xB2);
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x6F);
  Wire.write(0xFF); Wire.write(0xFF);
  Wire.endTransmission();

  bank_sel(0x01);
  regWrite(0x6E, 0x90);

  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x6F);
  Wire.write(0x09); Wire.write(0x23); Wire.write(0xA1); Wire.write(0x35);
  Wire.endTransmission();

  temp = regRead(0x6A);

  regWrite(0x6A, 0x04);

  //Insert FIFO count read?
  fifoReady();

  regWrite(0x6A, 0x00);
  regWrite(0x6B, 0x03);

  delay(2);

  temp = regRead(0x6C);
  // Serial.println(temp, HEX);
  regWrite(0x6C, 0x00);
  temp = regRead(0x1C);
  // Serial.println(temp, HEX);
  regWrite(0x1C, 0x00);
  delay(2);
  temp = regRead(0x6B);
  // Serial.println(temp, HEX);
  regWrite(0x1F, 0x02);
  regWrite(0x21, 0x9C);
  regWrite(0x20, 0x50);
  regWrite(0x22, 0x00);
  regWrite(0x6A, 0x04);
  regWrite(0x6A, 0x00);
  regWrite(0x6A, 0xC8);

  bank_sel(0x01);
  regWrite(0x6E, 0x6A);
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x6F);
  Wire.write(0x06); Wire.write(0x00);
  Wire.endTransmission();

  bank_sel(0x01);
  regWrite(0x6E, 0x60);
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x6F);
  for (byte i = 0; i < 8; i++) {
    Wire.write(0x00);
  }
  Wire.endTransmission();
  bank_sel(0x00);
  regWrite(0x6E, 0x60);
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x6F);
  Wire.write(0x40); Wire.write(0x00); Wire.write(0x00); Wire.write(0x00);
  Wire.endTransmission();

  //resetFifo();
}

void regWrite(byte addy, byte regUpdate) {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(addy);
  Wire.write(regUpdate);
  Wire.endTransmission();
}

byte regRead(byte addy) {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(addy);
  Wire.endTransmission();
  Wire.beginTransmission(MPU_ADDR);
  Wire.requestFrom(MPU_ADDR, 1);
  // Wire.endTransmission();
  while (!Wire.available()) {
  }
  byte incoming = Wire.read();
  return incoming;
}

void getPacket() {
  if (fifoCountL > 32) {
    fifoCountL2 = fifoCountL - 32;
    longPacket = true;
  }
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x74);
  Wire.endTransmission();
  // Wire.requestFrom(MPU_ADDR, 42);
  // for(byte i = 0; i < fifoCountL; i++){
  if (longPacket) {
    Wire.beginTransmission(MPU_ADDR);
    Wire.requestFrom(MPU_ADDR, 32);
    for (byte i = 0; i < 32; i++) {
      received_packet[i] = Wire.read();
    }
    Wire.beginTransmission(MPU_ADDR);
    Wire.write(0x74);
    Wire.endTransmission();
    Wire.beginTransmission(MPU_ADDR);
    Wire.requestFrom(MPU_ADDR, (unsigned int)fifoCountL2);
    for (byte i = 32; i < fifoCountL; i++) {
      received_packet[i] = Wire.read();
    }
    longPacket = false;
  }
  else {
    Wire.beginTransmission(MPU_ADDR);
    Wire.requestFrom(MPU_ADDR, (unsigned int)fifoCountL);
    for (byte i = 0; i < fifoCountL; i++) {
      received_packet[i] = Wire.read();
    }
  }
}

byte read_interrupt() {
  byte int_status = regRead(0x3A);
  return int_status;
}

boolean fifoReady() {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x72);
  Wire.endTransmission();
  Wire.beginTransmission(MPU_ADDR);
  Wire.requestFrom(MPU_ADDR, 2);
  // Wire.endTransmission();
  byte fifoCountH = Wire.read();
  fifoCountL = Wire.read();
   //Serial.println(fifoCountL, DEC);
  if (fifoCountL == 42 || fifoCountL == 44) {
    return 1;
  }
  else if(fifoCountL != 0){
    resetFifo();
 }
  else return 0;
}

void resetFifo() {
  byte ctrl = regRead(0x6A);
  ctrl |= 0b00000100;
  regWrite(0x6A, ctrl);
}

void check_MPU() {

  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x75);
  Wire.endTransmission();
  Wire.beginTransmission(MPU_ADDR);
  Wire.requestFrom(MPU_ADDR, 1);
  byte aByte = Wire.read();
  //Serial.print("aByte : ");
  //Serial.println(aByte);
  if (aByte == 0x68) {
    Serial.println("Found MPU6050");
  }
  else {
    Serial.println("Didn't find MPU6050");
  }
}

void processQuat() {
  processed_packet[0] = received_packet[0];
  processed_packet[1] = received_packet[1];
  processed_packet[2] = received_packet[4];
  processed_packet[3] = received_packet[5];
  processed_packet[4] = received_packet[8];
  processed_packet[5] = received_packet[9];
  processed_packet[6] = received_packet[12];
  processed_packet[7] = received_packet[13];

}

void sendQuat() {
  q[0] = (long) ((((unsigned long) processed_packet[0]) << 8) + ((unsigned long) processed_packet[1]));
  q[1] = (long) ((((unsigned long) processed_packet[2]) << 8) + ((unsigned long) processed_packet[3]));
  q[2] = (long) ((((unsigned long) processed_packet[4]) << 8) + ((unsigned long) processed_packet[5]));
  q[3] = (long) ((((unsigned long) processed_packet[6]) << 8)  + ((unsigned long) processed_packet[7]));
  for (int i = 0; i < 4; i++ ) {
    if ( q[i] > 32767 ) {
      q[i] -= 65536;
    }
    q[i] = ((float) q[i]) / 16384.0f;
  }
  serialPrintFloatArr(q, 4);
  Serial.print("\n");
}

void sendPacket() {
  for (byte i = 0; i < fifoCountL - 1; i++) {
    Serial.print(received_packet[i], HEX); Serial.print(" ");
  }
  Serial.println(received_packet[fifoCountL - 1], HEX); Serial.println();
}

void sendHeader() {
  for (byte i = 0; i < 2; i++) {
    Serial.print(received_packet[i], HEX); Serial.print(" ");
  }
  Serial.println();
}

void bank_sel(byte bank) {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x6D);
  Wire.write(bank);
  Wire.endTransmission();
}

void serialPrintFloatArr(float * arr, int length) {
  for (int i = 0; i < length; i++) {
    serialFloatPrint(arr[i]);
    Serial.print(",");
  }
}

void serialFloatPrint(float f) {
  byte * b = (byte *) &f;
  for (int i = 0; i < 4; i++) {

    byte b1 = (b[i] >> 4) & 0x0f;
    byte b2 = (b[i] & 0x0f);

    char c1 = (b1 < 10) ? ('0' + b1) : 'A' + b1 - 10;
    char c2 = (b2 < 10) ? ('0' + b2) : 'A' + b2 - 10;

    Serial.print(c1);
    Serial.print(c2);
  }
}
